/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	base "kubeform.dev/apimachinery/api/v1alpha1"

	core "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kmapi "kmodules.xyz/client-go/api/v1"
	"sigs.k8s.io/cli-utils/pkg/kstatus/status"
)

// +genclient
// +k8s:openapi-gen=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`

type LogsOutputGraylogStream struct {
	metav1.TypeMeta   `json:",inline,omitempty"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              LogsOutputGraylogStreamSpec   `json:"spec,omitempty"`
	Status            LogsOutputGraylogStreamStatus `json:"status,omitempty"`
}

type LogsOutputGraylogStreamSpec struct {
	State *LogsOutputGraylogStreamSpecResource `json:"state,omitempty" tf:"-"`

	Resource LogsOutputGraylogStreamSpecResource `json:"resource" tf:"resource"`

	UpdatePolicy base.UpdatePolicy `json:"updatePolicy,omitempty" tf:"-"`

	TerminationPolicy base.TerminationPolicy `json:"terminationPolicy,omitempty" tf:"-"`

	ProviderRef core.LocalObjectReference `json:"providerRef" tf:"-"`

	BackendRef *core.LocalObjectReference `json:"backendRef,omitempty" tf:"-"`
}

type LogsOutputGraylogStreamSpecResource struct {
	ID string `json:"id,omitempty" tf:"id,omitempty"`

	// Indicates if the current user can create alert on the stream
	// +optional
	CanAlert *bool `json:"canAlert,omitempty" tf:"can_alert"`
	// Cold storage compression method
	// +optional
	ColdStorageCompression *string `json:"coldStorageCompression,omitempty" tf:"cold_storage_compression"`
	// ColdStorage content
	// +optional
	ColdStorageContent *string `json:"coldStorageContent,omitempty" tf:"cold_storage_content"`
	// Is Cold storage enabled?
	// +optional
	ColdStorageEnabled *bool `json:"coldStorageEnabled,omitempty" tf:"cold_storage_enabled"`
	// Notify on new Cold storage archive
	// +optional
	ColdStorageNotifyEnabled *bool `json:"coldStorageNotifyEnabled,omitempty" tf:"cold_storage_notify_enabled"`
	// Cold storage retention in year
	// +optional
	ColdStorageRetention *int64 `json:"coldStorageRetention,omitempty" tf:"cold_storage_retention"`
	// ColdStorage destination
	// +optional
	ColdStorageTarget *string `json:"coldStorageTarget,omitempty" tf:"cold_storage_target"`
	// Stream creation
	// +optional
	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at"`
	// Stream description
	Description *string `json:"description" tf:"description"`
	// Enable ES indexing
	// +optional
	IndexingEnabled *bool `json:"indexingEnabled,omitempty" tf:"indexing_enabled"`
	// Maximum indexing size (in GB)
	// +optional
	IndexingMaxSize *int64 `json:"indexingMaxSize,omitempty" tf:"indexing_max_size"`
	// If set, notify when size is near 80, 90 or 100 % of the maximum configured setting
	// +optional
	IndexingNotifyEnabled *bool `json:"indexingNotifyEnabled,omitempty" tf:"indexing_notify_enabled"`
	// Indicates if you are allowed to edit entry
	// +optional
	IsEditable *bool `json:"isEditable,omitempty" tf:"is_editable"`
	// Indicates if you are allowed to share entry
	// +optional
	IsShareable *bool `json:"isShareable,omitempty" tf:"is_shareable"`
	// Number of alert condition
	// +optional
	NbAlertCondition *int64 `json:"nbAlertCondition,omitempty" tf:"nb_alert_condition"`
	// Number of coldstored archives
	// +optional
	NbArchive *int64 `json:"nbArchive,omitempty" tf:"nb_archive"`
	// Parent stream ID
	// +optional
	ParentStreamID *string `json:"parentStreamID,omitempty" tf:"parent_stream_id"`
	// If set, pause indexing when maximum size is reach
	// +optional
	PauseIndexingOnMaxSize *bool `json:"pauseIndexingOnMaxSize,omitempty" tf:"pause_indexing_on_max_size"`
	// Retention ID
	// +optional
	RetentionID *string `json:"retentionID,omitempty" tf:"retention_id"`
	// The service name
	ServiceName *string `json:"serviceName" tf:"service_name"`
	// Stream ID
	// +optional
	StreamID *string `json:"streamID,omitempty" tf:"stream_id"`
	// Stream description
	Title *string `json:"title" tf:"title"`
	// Stream last update
	// +optional
	UpdatedAt *string `json:"updatedAt,omitempty" tf:"updated_at"`
	// Enable Websocket
	// +optional
	WebSocketEnabled *bool `json:"webSocketEnabled,omitempty" tf:"web_socket_enabled"`
}

type LogsOutputGraylogStreamStatus struct {
	// Resource generation, which is updated on mutation by the API Server.
	// +optional
	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
	// +optional
	Phase status.Status `json:"phase,omitempty"`
	// +optional
	Conditions []kmapi.Condition `json:"conditions,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true

// LogsOutputGraylogStreamList is a list of LogsOutputGraylogStreams
type LogsOutputGraylogStreamList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	// Items is a list of LogsOutputGraylogStream CRD objects
	Items []LogsOutputGraylogStream `json:"items,omitempty"`
}
